---
layout: post
title: The journey of a Symfony API from 150ms to 20ms
date: 2016-11-26 17:19:09.000000000 +02:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Tehnic
tags:
- performance
- php
- programming
- symfony
meta:
  _edit_last: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1546141150;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:277;}i:1;a:1:{s:2:"id";i:196;}i:2;a:1:{s:2:"id";i:270;}}}}
  _wpas_done_all: '1'
  _jetpack_dont_email_post_to_subs: '1'
  _lf_language_code: en-US
  _schema_article: a:12:{s:6:"active";N;s:8:"headline";N;s:16:"mainEntityOfPage";N;s:6:"author";N;s:5:"image";N;s:13:"datePublished";N;s:12:"dateModified";N;s:9:"publisher";N;s:14:"publisherImage";N;s:11:"description";N;s:11:"articleBody";N;s:19:"alternativeHeadline";N;}
  _schema_blog_posting: a:11:{s:6:"active";N;s:8:"headline";N;s:16:"mainEntityOfPage";N;s:6:"author";N;s:5:"image";N;s:13:"datePublished";N;s:12:"dateModified";N;s:9:"publisher";N;s:14:"publisherImage";N;s:11:"description";N;s:11:"articleBody";N;}
  _schema_news_article: a:11:{s:6:"active";N;s:8:"headline";N;s:16:"mainEntityOfPage";N;s:6:"author";N;s:5:"image";N;s:13:"datePublished";N;s:12:"dateModified";N;s:9:"publisher";N;s:14:"publisherImage";N;s:11:"description";N;s:11:"articleBody";N;}
  _schema_event: a:12:{s:6:"active";N;s:4:"name";N;s:12:"locationName";N;s:15:"locationAddress";N;s:9:"startDate";N;s:7:"endDate";N;s:11:"description";N;s:13:"performerName";N;s:5:"image";N;s:5:"price";N;s:13:"priceCurrency";N;s:3:"url";N;}
  _schema_product: a:12:{s:6:"active";N;s:4:"name";N;s:5:"image";N;s:11:"description";N;s:5:"brand";N;s:11:"ratingValue";N;s:11:"reviewCount";N;s:5:"price";N;s:13:"priceCurrency";N;s:12:"availability";N;s:13:"itemCondition";N;s:3:"url";N;}
  _schema_video: a:10:{s:6:"active";N;s:4:"name";N;s:11:"description";N;s:12:"thumbnailUrl";N;s:10:"uploadDate";N;s:8:"duration";N;s:10:"contentUrl";N;s:8:"embedUrl";N;s:16:"interactionCount";N;s:7:"expires";N;}
  _schema_service: a:13:{s:6:"active";N;s:4:"name";N;s:11:"serviceType";N;s:14:"additionalType";N;s:5:"award";N;s:8:"category";N;s:16:"providerMobility";N;s:11:"description";N;s:5:"image";N;s:16:"mainEntityOfPage";N;s:6:"sameAs";N;s:3:"url";N;s:13:"alternateName";N;}
  _schema_review: a:10:{s:6:"active";N;s:8:"itemName";N;s:10:"reviewBody";N;s:4:"name";N;s:6:"author";N;s:13:"datePublished";N;s:11:"ratingValue";N;s:10:"bestRating";N;s:11:"worstRating";N;s:9:"publisher";N;}
  _schema_aggregate_rating: a:13:{s:6:"active";N;s:11:"schema_type";N;s:4:"name";N;s:5:"image";N;s:10:"priceRange";N;s:9:"telephone";N;s:7:"address";N;s:11:"description";N;s:11:"ratingCount";N;s:11:"reviewCount";N;s:11:"ratingValue";N;s:10:"bestRating";N;s:11:"worstRating";N;}
  _wpas_skip_16140044: '1'
  _wpas_skip_8301268: '1'
  _wpas_skip_16140053: '1'

---
<p>I have been involved in the development of an app based on symfony 2.8 which also used solr, Mongo and redis.</p>
<p>The problem at hand: response times were slow (see table below). With some bold objectives we went down the road.<br />
[jtrt_tables id='205']</p>
<h3>Start</h3>
<p>Best practices says to enable caching, but before going there let's try to see what can we optimize, as caching may make some things harder to discover.</p>
<p>At this point you should make sure that you have the proper measuring tools (APM and load testing). For this we have used <a href="http://jmeter.apache.org/">jmeter</a> and <a href="https://newrelic.com/">free new relic</a>. Get some numbers before starting the process and have patience (some results will start be seen after days).</p>
<h3>Use your DB engine properly</h3>
<p>What i mean is for mysql/mongo for example put in place proper indexes and analyse the queries your run.<br />
Think about that a query that you runs every few hours could lock your tables/collections for a few seconds and this could increase your response time. Our particular case was in regards to missing indexes in mongo.</p>
<p>Another bottleneck were the Solr query. We have made some tweaks to both schema and config of the solr it self and boom.... from calls that took 2-3 seconds... we don't have any above 500ms (the 99% at 3000 was mostly generated by solr calls)</p>
<h3>Use the latest versions</h3>
<p>Or at least somewhere around :). For example our upgrade from</p>
<p>php5.6 to php70 has helped us with a boost of 25% (and some headaches dues to required upgrade of Mongo driver and doctrine missing native support for the new driver).</p>
<p style="padding-left: 30px;"><strong>Update 2016.12.1:</strong> Someone asked about the upgrade of doctrine+mongo to PHP 7. As many may have observed already, the old driver is deprecated and doctrine-mongo-odm is not compatible with the new driver. But someone made a cool transition package (https://github.com/alcaeus/mongo-php-adapter) that worked great for us.<br />
Another problem encountered during the upgrade of ODM was related to the field annotation, that we had to migrate from @MongoDB\String @MongoDB\Int to @MongoDB\Field(type="string")</p>
<p>upgrade Mongo from 2.4 to 3.2 - well... someone used a very old version of Mongo when the cluster was made. This was a bit tricky as we had to take the whole app down for about 1 hour as we couldn't migrate from 2.4 to 3.2 without taking a full backup and restoring it on a new cluster.</p>
<h3>Bundles</h3>
<p>If you don't need it, remove it! If you need it in development, load it just in dev/test env.</p>
<p>Some examples of bundles disabled on our app were:</p>
<ul>
<li>SecurityBundle - our API is read-only and it's nothing that needs to be protected (or at least you could declare a dedicated firewall for the public API sections)</li>
<li>SwiftMailerBundle</li>
<li>SensioFrameworkExtraBundle</li>
<li>TwigBundle</li>
<li>AsseticBundle</li>
</ul>
<h3>Configs</h3>
<p>Make sure all configs are in production mode. Some examples would be:</p>
<ul>
<li>make as little as possible IO (also consider logs in the process)</li>
<li>Doctrine makes a lot of cache files for metadata. Put it in APC/APCU.
<pre>doctrine_mongodb:
    connections:
        default:
            server: mongodb://%mongo_servers%
            options:
                connect: true
                connectTimeoutMS: 300
    default_database: %database_name%
    document_managers:
        default:
            <strong>metadata_cache_driver: apc</strong>
            retry_connect:              1
            retry_query:                1
            auto_mapping: true</pre>
</li>
<li>persistent connections where possible (we had some problems with redis after doing this, because we were using 2 databases for different purposes and switching dbs... was a nightmare)</li>
<li>Make sure you read from slaves. (we were killing the Mongo master because of this)
<ul>
<li>Here we need to control when to read from slave... so we haven't allowed it by default, but we enabled it on demand:
<pre>$container-&gt;get('doctrine_mongodb')-&gt;getManager()-&gt;getClassMetadata('&lt;Entity Name&gt;')-&gt;slaveOkay = true</pre>
</li>
</ul>
</li>
<li>Try to consider what the timeout of the clients are and use them in your app. If you know your client is ignoring your response, why bother completing the entire request (example: timeout -300ms, but a internal http call takes 3000ms. This would keep you busy for nothing )</li>
</ul>
<h3>Queue it!</h3>
<p>If you don't need something now, just put in a queue and continue with serving requests. Write operations (to db or disk) are usually heavier than putting it on a queue and handling it on a separate server.</p>
<p>We use RabbitMQ with this bundle: <a href="https://github.com/php-amqplib/RabbitMqBundle">https://github.com/php-amqplib/RabbitMqBundle</a></p>
<h3>Twig</h3>
<p>It's an API and we chose to have twig enabled only in dev environment (so that we can have the profiler work). :)</p>
<p>Try to use php directly, but if you can't live without it, at least install php twig extension (brings some boost in performance)</p>
<h3>Container / DI</h3>
<p>Here we also did a little comparison with other bare frameworks like slilex. We choose to stay with symfony as the performance penalty was minor compared with the advantages:</p>
<ul>
<li>yml configs were actually cached as php code at deploy</li>
<li>yml errors were caught during deploy phase (at cache warmup) and faulty containers can not be released live</li>
<li>Personally I started to use a lot ContainerPass'es and also "tags"</li>
<li>We already knew how to define and use services in symfony and brining a new framework make lead to some beginner mistakes.</li>
</ul>
<h3>Cache</h3>
<p>This was one of the final steps we added. A few tricks to be considered here:</p>
<ul>
<li>Make sure your connection to the cache server is persistent</li>
<li>Consider with what TTL you should cache (depending on change freq). If you have a large data set and freq updates on various events, you can set a high TTL and make the update process to also flush the cache</li>
<li>you can try multi level caches if you need it (apc + memcache), but it will also generate some headaches</li>
<li>To avoid complicated logic inside your methods you could use a cool caching bundle: https://github.com/eMAGTechLabs/cachebundle</li>
<li>You might have a lot of cache evictions due to large cache.
<ul>
<li>Try to reduce the size of caches (is it really required that often?)</li>
<li>Add additional capacity to the caching server.</li>
</ul>
</li>
</ul>
<h3>Nginx / FPM config</h3>
<p>Here we did some changes after we discovered that under high load we had increased response time, but our servers were free (CPU and memory). We have increase the number of worker/child processes for both nginx and php-fpm and this allowed us higher load.</p>
